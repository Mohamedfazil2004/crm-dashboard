import React, { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';

const Dashboard = () => {
  const { user } = useAuth();
  const isAdmin = user?.role === 'Admin';

  const [clientInfo, setClientInfo] = useState({
    clientName: '', industry: '', deliveryDate: '', phone: '', email: ''
  });
  const [activeService, setActiveService] = useState('Web');

  // 1. Updated State: Added 'min' to Calls
  const [deliverables, setDeliverables] = useState({
    Web: { checked: false, count: 1, amount: 0, min: 0, description: '' },
    SEO: { checked: false, count: 1, amount: 0, min: 0, description: '' },
    Campaign: { checked: false, count: 1, amount: 0, min: 0, description: '' },
    Calls: { checked: false, count: 0, amount: 0, min: 0, description: '' }, // Added min here
    Posters: { checked: false, count: 0, min: 0, amo: 0 },
    Reels: { checked: false, count: 0, min: 0, amo: 0 },
    Shorts: { checked: false, count: 0, min: 0, amo: 0 },
    Longform: { checked: false, count: 0, min: 0, amo: 0 },
    Carousel: { checked: false, count: 0, min: 0, amo: 0 },
    EventDay: { checked: false, count: 0, amo: 0 },
    Blog: { checked: false, count: 0, min: 0, amo: 0 }
  });

  const [existingClients, setExistingClients] = useState([]);
  const [tableRows, setTableRows] = useState([]);

  const [showAssignDropdown, setShowAssignDropdown] = useState(false);
  const [formError, setFormError] = useState('');

  useEffect(() => {
    fetchClientRequests();
  }, []);

  const fetchClientRequests = async () => {
    try {
      const token = localStorage.getItem('access_token');
      const res = await fetch('/api/clients', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      if (res.ok) {
        const data = await res.json();
        const processed = data.map(c => {
          // Normalize requirements - ensure all deliverables exist even if not in DB
          const defaults = {
            Web: { checked: false, count: 0, amount: 0, min: 0 },
            SEO: { checked: false, count: 0, amount: 0, min: 0 },
            Campaign: { checked: false, count: 0, amount: 0, min: 0 },
            Calls: { checked: false, count: 0, amount: 0, min: 0 },
            Posters: { checked: false, count: 0, min: 0 },
            Reels: { checked: false, count: 0, min: 0 },
            Shorts: { checked: false, count: 0, min: 0 },
            Longform: { checked: false, count: 0, min: 0 },
            Carousel: { checked: false, count: 0, min: 0 },
            EventDay: { checked: false, count: 0 },
            Blog: { checked: false, count: 0, min: 0 }
          };

          const mergedRequirements = { ...defaults, ...(c.requirements || {}) };

          return {
            ...c,
            ...mergedRequirements,
            requirements: mergedRequirements,
            activityCodes: c.activityCodes || {}
          };
        });
        setExistingClients(processed);
        // Default filter for Dashboard: hide Sent and Archived
        setTableRows(processed.filter(c => c.status !== 'Archived' && c.status !== 'Sent'));
      }
    } catch (error) {
      console.error("Error fetching clients:", error);
    }
  };

  const generateClientID = () => {
    // Client ID is generated by backend, but we keep this helper if needed for temp display
    return "PENDING";
  };

  const generateActivityCode = (clientID, type, countSequence = 1) => {
    // Activity codes are ideally generated by backend, but keeping for now as placeholder
    return "PENDING";
  };

  const handleInputChange = (e) => setClientInfo({ ...clientInfo, [e.target.id]: e.target.value });

  const handleDeliverableChange = (key, field, value) => {
    setDeliverables(prev => {
      const current = { ...prev[key] };
      if (field === 'checked') {
        current.checked = value;
        if (!value) {
          current.count = 0; current.min = 0; current.amo = 0; current.amount = 0; current.description = '';
        } else if (['Web', 'SEO', 'Campaign'].includes(key)) {
          current.count = 1;
        }
      } else if (field === 'description') {
        current.description = value;
      } else {
        current[field] = parseInt(value) || 0;
      }
      return { ...prev, [key]: current };
    });
  };

  const handleAssignClient = (clientID) => {
    const client = existingClients.find(c => c.clientID === clientID);
    if (client) {
      setClientInfo({
        clientName: client.clientName, industry: client.industry,
        deliveryDate: client.deliveryDate ? client.deliveryDate.split(' ')[0] : '',
        phone: client.phone, email: client.email
      });
      setShowAssignDropdown(false);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    const isAnySelected = Object.values(deliverables).some(d => d.checked);
    if (!isAnySelected) {
      setFormError('Please select at least one deliverable.');
      setTimeout(() => setFormError(''), 3000);
      return;
    }

    const payload = {
      ...clientInfo,
      requirements: deliverables
    };

    try {
      const token = localStorage.getItem('access_token');
      const res = await fetch('/api/clients', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(payload)
      });

      const data = await res.json();

      if (res.ok) {
        alert("Client Request Saved Successfully!");
        // Refresh list
        fetchClientRequests();
      } else {
        alert(data.message || "Failed to save request");
      }
    } catch (error) {
      console.error("Error saving client:", error);
      alert("Error connecting to server");
    }
  };

  const handleBatchSend = async (row, assignments) => {
    if (isAdmin) return alert("Read-only access: Admin cannot perform this action.");
    if (!assignments || assignments.length === 0) return alert("No services selected for assignment!");

    // Capture the manager's send timestamp (to Team)
    const now = new Date();
    const datePart = now.toISOString().split('T')[0];
    const timePart = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
    const clientSentAt = `${datePart} | ${timePart}`;

    // 1. Prepare tasks for each specific assignment
    const backendTasks = [];
    assignments.forEach(({ type, team }) => {
      const taskKey = `${team.toLowerCase()}Tasks`;
      const activityCode = row.activityCodes?.[type] || "PENDING";

      const baseTask = {
        client: row.clientName,
        clientID: row.clientID,
        activityCode,
        activityType: row.industry,
        deliveryDate: row.deliveryDate,
        clientSentAt,
        phone: row.phone,
        email: row.email,
        status: "Pending",
        serviceType: type
      };

      let newTask = {};

      if (team === "Website" || team === "SEO" || team === "Campaign") {
        const dataKey = type === "Web" ? "Web" : (type === "SEO" || type === "Campaign" ? type : "Web");
        const amt = row[dataKey]?.amo || row[dataKey]?.amount || 0;
        const mins = row[dataKey]?.min || 0;
        newTask = {
          ...baseTask,
          count: { [dataKey]: row[dataKey]?.count || 0 },
          amount: { [dataKey]: amt },
          minutes: { [dataKey]: mins },
          description: row[dataKey]?.description || ''
        };

        backendTasks.push({
          activityCode,
          clientID: row.clientID,
          team,
          serviceType: type,
          amount: parseInt(amt),
          minutes: parseInt(mins),
          clientSentAt
        });

      } else if (team === "Telecaller") {
        const amt = row.Calls?.amount || 0;
        const mins = row.Calls?.min || 0;
        newTask = {
          ...baseTask,
          count: { Calls: row.Calls?.count || 0 },
          amount: { Calls: amt },
          callsDescription: row.Calls?.description || '',
          minutes: { Calls: mins }
        };
        backendTasks.push({
          activityCode,
          clientID: row.clientID,
          team,
          serviceType: "Calls",
          amount: parseInt(amt),
          minutes: parseInt(mins),
          clientSentAt
        });
      } else {
        // Branding/Other - ONLY include the specific service being assigned
        newTask = {
          ...baseTask,
          minutes: { [type]: row[type]?.min || 0 },
          amount: { [type]: row[type]?.amo || row[type]?.amount || 0 },
          count: { [type]: row[type]?.count || 0 },
          callsDescription: row.Calls?.description || ''
        };

        const totalAmt = parseInt(row[type]?.amo || row[type]?.amount || 0);
        const totalMins = parseInt(row[type]?.min || 0);

        backendTasks.push({
          activityCode,
          clientID: row.clientID,
          team,
          serviceType: type,
          amount: totalAmt,
          minutes: totalMins,
          clientSentAt
        });
      }

      const existingTasks = JSON.parse(localStorage.getItem(taskKey)) || [];
      existingTasks.push(newTask);
      localStorage.setItem(taskKey, JSON.stringify(existingTasks));
    });

    // Send to Backend Task Table
    try {
      const token = localStorage.getItem('access_token');
      const taskRes = await fetch('/api/tasks/bulk', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(backendTasks)
      });
      if (!taskRes.ok) {
        console.warn("Failed to save tasks to database");
      }
    } catch (e) {
      console.error("Error saving tasks to backend:", e);
    }

    // 2. Update Backend Client Record Status & Requirements
    try {
      const token = localStorage.getItem('access_token');
      const deliverableKeys = ['Web', 'SEO', 'Campaign', 'Calls', 'Posters', 'Reels', 'Shorts', 'Longform', 'Carousel', 'EventDay', 'Blog'];

      const currentRequirements = row.requirements || {};
      const updatedRequirements = { ...currentRequirements };

      // Update the specific services in requirements
      deliverableKeys.forEach(key => {
        if (row[key]) {
          const matchingAssignment = assignments.find(a => a.type === key);
          if (matchingAssignment) {
            updatedRequirements[key] = {
              ...row[key],
              isSent: true,
              assignedTo: matchingAssignment.team,
              sentAt: clientSentAt
            };
          } else {
            // Keep existing state for others
            updatedRequirements[key] = { ...row[key] };
          }
        }
      });

      // Check if ALL checked services are now sent
      const checkedServices = deliverableKeys.filter(k => updatedRequirements[k] && updatedRequirements[k].checked);
      const allSent = checkedServices.every(k => updatedRequirements[k].isSent);

      // Determine final status: 'Sent' hides it from dashboard, 'Pending' keeps it
      const finalStatus = allSent ? 'Sent' : 'Pending';

      // Combine assigned teams cumulatively
      const existingTeams = row.assignedTeam ? row.assignedTeam.split(',').map(t => t.trim()) : [];
      const newTeams = assignments.map(a => a.team);
      const combinedTeamsList = [...new Set([...existingTeams, ...newTeams])].filter(t => t);
      const combinedTeamsString = combinedTeamsList.join(', ');

      const res = await fetch(`/api/clients/${row.clientID}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          requirements: updatedRequirements,
          status: finalStatus,
          assignedTeam: combinedTeamsString
        })
      });

      if (res.ok) {
        // Sync local state
        const updatedList = existingClients.map(client => {
          if (client.clientID === row.clientID) {
            return {
              ...client,
              ...updatedRequirements,
              requirements: updatedRequirements,
              status: finalStatus,
              assignedTeam: combinedTeamsString
            };
          }
          return client;
        });

        setExistingClients(updatedList);
        setTableRows(updatedList.filter(c => c.status !== 'Archived' && c.status !== 'Sent'));
        localStorage.setItem("allClients", JSON.stringify(updatedList));

        const msg = allSent ? "Record marked as fully Sent." : "Service assigned. Client remains for other service assignments.";
        alert(`Successfully assigned ${assignments.length} service(s). ${msg}`);
      } else {
        const err = await res.json();
        alert(`Failed to update backend: ${err.message}`);
      }
    } catch (error) {
      console.error("Backend update error:", error);
      alert("Network error while updating backend status");
    }
  };

  const renderReqItem = (key, label, hasMinutes = true) => {
    const item = deliverables[key];
    return (
      <label className="req-item" key={key}>
        <div style={{ display: 'flex', alignItems: 'center', width: '100%' }}>
          <input
            type="checkbox"
            checked={item.checked}
            onChange={(e) => !isAdmin && handleDeliverableChange(key, 'checked', e.target.checked)}
            disabled={isAdmin}
          />
          <span style={{ width: '100px', fontWeight: '500' }}>{label}</span>
          <div className="compact-group">
            <input
              type="number" className="req-count" placeholder="Cnt"
              disabled={isAdmin || !item.checked} value={item.count}
              onChange={(e) => !isAdmin && handleDeliverableChange(key, 'count', e.target.value)}
            />
            <span>/ Amo:</span>
            <input
              type="number" className="req-amount" placeholder="Amt"
              disabled={isAdmin || !item.checked} value={item.amo || item.amount || 0}
              onChange={(e) => !isAdmin && handleDeliverableChange(key, 'amount', e.target.value)}
            />
            {hasMinutes && (
              <>
                <span>Min:</span>
                <input
                  type="number" className="req-minutes" placeholder="Min"
                  disabled={isAdmin || !item.checked} value={item.min}
                  onChange={(e) => !isAdmin && handleDeliverableChange(key, 'min', e.target.value)}
                />
              </>
            )}
          </div>
        </div>
      </label>
    );
  };


  return (
    <div className="container" style={{ position: 'relative' }}>
      <h1>Client Request Dashboard</h1>

      {!isAdmin && (
        <div style={{ position: 'absolute', top: '30px', right: '40px' }}>
          <button onClick={() => setShowAssignDropdown(!showAssignDropdown)}>
            üîÑ Assign Client
          </button>
          {showAssignDropdown && (
            <div style={{ position: 'absolute', right: 0, top: '45px', background: '#fff', border: '1px solid #ccc', padding: '10px', borderRadius: '8px', zIndex: 100, minWidth: '200px', maxHeight: '200px', overflowY: 'auto' }}>
              <p style={{ fontSize: '12px', color: '#666', marginBottom: '5px' }}>Select existing client:</p>
              {existingClients.length === 0 && <p style={{ fontSize: '12px' }}>No clients found</p>}
              {existingClients.map(c => (
                <div
                  key={c.clientID}
                  onClick={() => handleAssignClient(c.clientID)}
                  style={{ padding: '5px', cursor: 'pointer', borderBottom: '1px solid #eee', fontSize: '13px' }}
                >
                  {c.clientID} - {c.clientName}
                </div>
              ))}
            </div>
          )}
        </div>
      )}

      <form className="form-section" onSubmit={handleSubmit}>
        <div className="form-grid">
          <input type="text" id="clientName" placeholder="Client Name" value={clientInfo.clientName} onChange={handleInputChange} required disabled={isAdmin} />
          <input type="text" id="industry" placeholder="Industry" value={clientInfo.industry} onChange={handleInputChange} required disabled={isAdmin} />
          <input type="date" id="deliveryDate" value={clientInfo.deliveryDate} onChange={handleInputChange} required disabled={isAdmin} />
          <input type="tel" id="phone" placeholder="Phone Number" value={clientInfo.phone} onChange={handleInputChange} required disabled={isAdmin} />
          <input type="email" id="email" placeholder="Email ID" value={clientInfo.email} onChange={handleInputChange} required disabled={isAdmin} />
        </div>

        <h3 className="section-title">Monthly Deliverable Requirements</h3>

        <div className="requirements-grid">

          <label className="req-item" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
            <div style={{ display: 'flex', alignItems: 'center', width: '100%', marginBottom: deliverables[activeService].checked ? '10px' : '0' }}>
              <input
                type="checkbox"
                checked={deliverables[activeService].checked}
                onChange={(e) => !isAdmin && handleDeliverableChange(activeService, 'checked', e.target.checked)}
                disabled={isAdmin}
              />
              <select
                value={activeService}
                onChange={(e) => setActiveService(e.target.value)}
                style={{ width: '100px', fontWeight: '500', marginRight: '10px', border: 'none', background: 'transparent', cursor: isAdmin ? 'default' : 'pointer' }}
                disabled={isAdmin}
              >
                <option value="Web">Web</option>
                <option value="SEO">SEO</option>
                <option value="Campaign">Campaign</option>
              </select>

              <div className="compact-group">
                <input type="number" className="req-count" placeholder="Cnt" disabled value={deliverables[activeService].count} />
                <span>/ Amo:</span>
                <input
                  type="number" className="req-amount" placeholder="Amt"
                  disabled={isAdmin || !deliverables[activeService].checked}
                  value={deliverables[activeService].amount}
                  onChange={(e) => !isAdmin && handleDeliverableChange(activeService, 'amount', e.target.value)}
                />
                <span>Min:</span>
                <input
                  type="number" className="req-minutes" placeholder="Min"
                  disabled={isAdmin || !deliverables[activeService].checked}
                  value={deliverables[activeService].min}
                  onChange={(e) => !isAdmin && handleDeliverableChange(activeService, 'min', e.target.value)}
                />
              </div>
            </div>
            {deliverables[activeService].checked && (
              <input
                type="text"
                placeholder={`Enter ${activeService} Description...`}
                value={deliverables[activeService].description}
                onChange={(e) => !isAdmin && handleDeliverableChange(activeService, 'description', e.target.value)}
                style={{ width: '100%', fontSize: '13px', padding: '8px', border: '1px solid #ccc', borderRadius: '4px' }}
                disabled={isAdmin}
              />
            )}
          </label>

          {renderReqItem('Posters', 'Post (P)')}
          {renderReqItem('Reels', 'Reel (R)')}
          {renderReqItem('Shorts', 'Shorts (YTS)')}
          {renderReqItem('Longform', 'Longform (YT)')}
          {renderReqItem('Carousel', 'Carousel (C)')}
          {renderReqItem('EventDay', 'Event Day', false)}
          {renderReqItem('Blog', 'Blog')}

          <label className="req-item" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
            <div style={{ display: 'flex', alignItems: 'center', width: '100%', marginBottom: deliverables.Calls.checked ? '10px' : '0' }}>
              <input
                type="checkbox"
                checked={deliverables.Calls.checked}
                onChange={(e) => !isAdmin && handleDeliverableChange('Calls', 'checked', e.target.checked)}
                disabled={isAdmin}
              />
              <span style={{ width: '100px', fontWeight: '500' }}>Calls</span>
              <div className="compact-group">
                <input
                  type="number" className="req-count" placeholder="Cnt"
                  disabled={isAdmin || !deliverables.Calls.checked}
                  value={deliverables.Calls.count}
                  onChange={(e) => !isAdmin && handleDeliverableChange('Calls', 'count', e.target.value)}
                />
                <span>/ Amo:</span>
                <input
                  type="number" className="req-amount" placeholder="Amt"
                  disabled={isAdmin || !deliverables.Calls.checked}
                  value={deliverables.Calls.amount}
                  onChange={(e) => !isAdmin && handleDeliverableChange('Calls', 'amount', e.target.value)}
                />
                {/* 2. Added Min Input for Calls */}
                <span>Min:</span>
                <input
                  type="number" className="req-minutes" placeholder="Min"
                  disabled={isAdmin || !deliverables.Calls.checked}
                  value={deliverables.Calls.min}
                  onChange={(e) => !isAdmin && handleDeliverableChange('Calls', 'min', e.target.value)}
                />
              </div>
            </div>
            {deliverables.Calls.checked && (
              <input
                type="text"
                placeholder="Enter Call Description..."
                value={deliverables.Calls.description}
                onChange={(e) => !isAdmin && handleDeliverableChange('Calls', 'description', e.target.value)}
                style={{ width: '100%', fontSize: '13px', padding: '8px', border: '1px solid #ccc', borderRadius: '4px' }}
                disabled={isAdmin}
              />
            )}
          </label>

        </div>

        {formError && <p className="error-msg" style={{ color: 'red', textAlign: 'center', marginTop: '10px' }}>{formError}</p>}
        {!isAdmin && <button type="submit" style={{ marginTop: '20px' }}>Submit Request</button>}
      </form>

      <div className="table-container">
        <table style={{ minWidth: '1300px' }}>
          <thead>
            <tr>
              <th style={{ width: '40px' }}>Sel</th>
              <th>Client</th>
              <th>Industry</th>
              <th>Delivery Date</th>
              <th>Contact Info</th>
              <th style={{ background: '#f8faff', borderBottom: '2px solid #007bff' }}>Deliverable Type</th>
              <th style={{ background: '#f8faff', borderBottom: '2px solid #007bff' }}>Count</th>
              <th style={{ background: '#f8faff', borderBottom: '2px solid #007bff' }}>Amount</th>
              <th style={{ background: '#f8faff', borderBottom: '2px solid #007bff' }}>Min</th>
              <th style={{ background: '#f8faff', borderBottom: '2px solid #007bff' }}>Description</th>
              <th style={{ background: '#f8faff', borderBottom: '2px solid #007bff' }}>Assign To</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody>
            {tableRows.length === 0 ? (
              <tr><td colSpan="12" style={{ textAlign: 'center', padding: '20px' }}>No Pending Client Requests</td></tr>
            ) : (
              tableRows.map((row, idx) => (
                <ClientDeliverableRows
                  key={row.clientID || idx}
                  row={row}
                  onSend={handleBatchSend}
                  isAdmin={isAdmin}
                />
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
};

const ClientDeliverableRows = ({ row, onSend, isAdmin }) => {
  const [rowStates, setRowStates] = useState({}); // { Web: { checked: false, team: "" }, ... }

  const deliverableKeys = [
    'Web', 'SEO', 'Campaign', 'Calls', 'Posters', 'Reels', 'Shorts',
    'Longform', 'Carousel', 'EventDay', 'Blog'
  ];

  const deliverableLabels = {
    Web: 'Web', SEO: 'SEO', Campaign: 'Campaign', Calls: 'Calls',
    Posters: 'Post (P)', Reels: 'Reel (R)', Shorts: 'Shorts (YTS)',
    Longform: 'Longform (YT)', Carousel: 'Carousel (C)', EventDay: 'Event Day',
    Blog: 'Blog'
  };

  const activeDeliverables = deliverableKeys.filter(key => row[key] && row[key].checked);

  const toggleRow = (type, checked) => {
    setRowStates(prev => ({
      ...prev,
      [type]: { ...prev[type], checked, team: checked ? (prev[type]?.team || "") : "" }
    }));
  };

  const setRowTeam = (type, team) => {
    setRowStates(prev => ({
      ...prev,
      [type]: { ...prev[type], team }
    }));
  };

  const handleSendRow = (type) => {
    const state = rowStates[type] || { checked: false, team: "" };

    if (!state.checked) {
      alert("Please select the checkbox for this row first.");
      return;
    }

    if (!state.team) {
      alert(`Please assign a team for ${deliverableLabels[type]} before sending.`);
      return;
    }

    if (isAdmin) return;
    onSend(row, [{ type, team: state.team }]);
  };

  if (activeDeliverables.length === 0) return null;

  return (
    <>
      {activeDeliverables.map((type, tIdx) => {
        const item = row[type];
        const isFirst = tIdx === 0;
        const state = rowStates[type] || { checked: false, team: "" };

        return (
          <tr key={`${row.clientID}-${type}`} style={{ borderBottom: isFirst && activeDeliverables.length > 1 ? 'none' : '1px solid #f1f1f1' }}>
            {/* Checkbox */}
            <td>
              <input
                type="checkbox"
                checked={state.checked}
                onChange={(e) => !isAdmin && toggleRow(type, e.target.checked)}
                style={{ width: '16px', height: '16px', cursor: isAdmin || item.isSent ? 'default' : 'pointer' }}
                disabled={isAdmin || item.isSent}
              />
            </td>

            {/* Client Info */}
            <td style={{ fontWeight: '600', color: isFirst ? '#007bff' : '#555' }}>
              {isFirst ? row.clientName : <span style={{ color: '#ccc', fontSize: '12px' }}>(cont.)</span>}
            </td>
            <td>{isFirst ? row.industry : ""}</td>
            <td>{isFirst ? row.deliveryDate : ""}</td>
            <td style={{ fontSize: '11px', textAlign: 'left' }}>
              {isFirst && (
                <>
                  <div>üìû {row.phone}</div>
                  <div>‚úâÔ∏è {row.email}</div>
                </>
              )}
            </td>

            {/* Deliverable Data */}
            <td style={{ fontWeight: '600', color: '#1a4f8a', background: '#fdfdff' }}>{deliverableLabels[type]}</td>
            <td style={{ fontWeight: 'bold' }}>{item.count || 0}</td>
            <td style={{ color: '#28a745', fontWeight: '600' }}>‚Çπ{item.amo || item.amount || 0}</td>
            <td>{item.min || 0}</td>
            <td style={{ maxWidth: '180px', fontSize: '11px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }} title={item.description}>
              {item.description || '-'}
            </td>

            {/* Independent Assign To */}
            <td style={{ minWidth: '150px' }}>
              <select
                value={state.team}
                onChange={(e) => !isAdmin && setRowTeam(type, e.target.value)}
                disabled={isAdmin || !state.checked || item.isSent}
                style={{
                  fontSize: '12px',
                  padding: '5px',
                  background: state.checked ? '#fff' : '#f2f2f2',
                  border: state.checked ? '1px solid #007bff' : '1px solid #ccc'
                }}
              >
                <option value="">Select Team</option>
                <option value="Website">Website Team</option>
                <option value="Branding">Branding Team</option>
                <option value="SEO">SEO Team</option>
                <option value="Campaign">Campaign Team</option>
                <option value="Telecaller">Telecaller Team</option>
              </select>
            </td>

            {/* Send Button */}
            <td>
              {!isAdmin && !item.isSent && (
                <button
                  onClick={() => handleSendRow(type)}
                  style={{
                    padding: '8px 12px',
                    fontSize: '11px',
                    background: '#28a745',
                    boxShadow: '0 2px 4px rgba(40,167,69,0.2)'
                  }}
                >
                  Send Selection
                </button>
              )}
              {item.isSent && (
                <span style={{ color: 'green', fontWeight: 'bold', fontSize: '12px' }}>‚úì Sent</span>
              )}
            </td>
          </tr>
        );
      })}
    </>
  );
};

export default Dashboard;